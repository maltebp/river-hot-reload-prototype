# Log

### River Hot-Reloading Prototype



- ... A lot of undocumented stuff

- I don't want to use nested classes, because they cannot be forward declared

- `PluginSystemType` is identified by its plugin name and system name (i.e. the *PluginSystemTypeId*)

  - Pointers to `PluginSystemType` cannot be stored, because the object is constructed at plugin restart, which means it will be re-constructed every time plugin is reloaded
  - In the future, the ID could constructed from a more stable name (i.e. could be retrieved via macro when registering the system)
  - We still have to expose a mapping between the `typeid(S).name()` of the system `S` and the `PluginSystemType`. But this string should *not be stored*, because it might change at every compilation.

- **Serialization**

  - The concrete plugin system has to provide the constructor that deserializes, but it should also be auto-generatable (for the future)

    - You can do this, by having the user add a macro to the system which defines the constructor and then provide implementation of constructor via a separate `.cpp` file (this way you don't touch the user's code)

  - Not using templates to deserialize cause some annoying access patterns:
    ```c++
    : hello_count(((rv::SerializedInt*)serialized_object- >properties.at("hello_count"))->value)
    
    ```

  - **Initialization order of systems**

    - Order of constructions *could* matter, because one system may depend on some value from another system. **But** deserialization is automated (and code should be autogenerated), and the only thing it does is that it sets the direct values (i.e. no dereferencing of maybe-uninitialized-system).


- **Main Plugin Serialization**
  - *The Problem:*
    The `MainPlugin` needs some kind of serialization, because it creates the first system(s), and these systems are the roots to the dependency tree of systems. This means the plugin must maintain some kind of reference to the system(s), which has to be  maintained on reload.
  - **Solution**
    - We now have an `EntryPointPluginSystem` which is exposed by the `EntryPointPlugin`. This system now contains the update function
    - We are not serializing the plugin, in order to keep it simple (i.e. only systems are serialized).
    - No constraints are put on whether the entry point system is initialized more than once - it is just a regular system, which exposes a parameter-less constructor.
- We opt for providing static assertion for `PluginSystemRef` instead of allowing forward-declaration (static assertions require classes to be defined, and not just declared)

  - I cannot come up with a way to allow for both.
  - As long as the systems provide rather simple APIs then I don't think it should be a big deal to no have forward declaration.

    - Changes to the `.hpp` file will cause recompile of all transient dependencies (e.g. when hot-reloading)
  - 