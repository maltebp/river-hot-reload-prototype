# Log

### River Hot-Reloading Prototype



- ... A lot of undocumented stuff

- I don't want to use nested classes, because they cannot be forward declared

- `PluginSystemType` is identified by its plugin name and system name (i.e. the *PluginSystemTypeId*)

  - Pointers to `PluginSystemType` cannot be stored, because the object is constructed at plugin restart, which means it will be re-constructed every time plugin is reloaded
  - In the future, the ID could constructed from a more stable name (i.e. could be retrieved via macro when registering the system)
  - We still have to expose a mapping between the `typeid(S).name()` of the system `S` and the `PluginSystemType`. But this string should *not be stored*, because it might change at every compilation.

- **Serialization**

  - The concrete plugin system has to provide the constructor that deserializes, but it should also be auto-generatable (for the future)

    - You can do this, by having the user add a macro to the system which defines the constructor and then provide implementation of constructor via a separate `.cpp` file (this way you don't touch the user's code)

  - Not using templates to deserialize cause some annoying access patterns:
    ```c++
    : hello_count(((rv::SerializedInt*)serialized_object- >properties.at("hello_count"))->value)
    
    ```

  - **Initialization order of systems**

    - Order of constructions *could* matter, because one system may depend on some value from another system. **But** deserialization is automated (and code should be autogenerated), and the only thing it does is that it sets the direct values (i.e. no dereferencing of maybe-uninitialized-system).


- **Plugin Serialization**
  - Plugins need serialization as well, because it is the plugins that construct the systems, and they need to maintain references to these systems after reloading