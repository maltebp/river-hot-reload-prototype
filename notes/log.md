# Log

### River Hot-Reloading Prototype



- ... A lot of undocumented stuff

- I don't want to use nested classes, because they cannot be forward declared

- `PluginSystemType` is identified by its plugin name and system name (i.e. the *PluginSystemTypeId*)

  - Pointers to `PluginSystemType` cannot be stored, because the object is constructed at plugin restart, which means it will be re-constructed every time plugin is reloaded
  - In the future, the ID could constructed from a more stable name (i.e. could be retrieved via macro when registering the system)
  - We still have to expose a mapping between the `typeid(S).name()` of the system `S` and the `PluginSystemType`. But this string should *not be stored*, because it might change at every compilation.

- **Serialization**

  - The concrete plugin system has to provide the constructor that deserializes, but it should also be auto-generatable (for the future)

    - You can do this, by having the user add a macro to the system which defines the constructor and then provide implementation of constructor via a separate `.cpp` file (this way you don't touch the user's code)

  - Not using templates to deserialize cause some annoying access patterns:
    ```c++
    : hello_count(((rv::SerializedInt*)serialized_object- >properties.at("hello_count"))->value)
    ```
    
- **Initialization order of systems**
  
  - Order of constructions *could* matter, because one system may depend on some value from another system. **But** deserialization is automated (and code should be autogenerated), and the only thing it does is that it sets the direct values (i.e. no dereferencing of maybe-uninitialized-system).


- **Main Plugin Serialization**
  - *The Problem:*
    The `MainPlugin` needs some kind of serialization, because it creates the first system(s), and these systems are the roots to the dependency tree of systems. This means the plugin must maintain some kind of reference to the system(s), which has to be  maintained on reload.
  - **Solution**
    - We now have an `EntryPointPluginSystem` which is exposed by the `EntryPointPlugin`. This system now contains the update function
    - We are not serializing the plugin, in order to keep it simple (i.e. only systems are serialized).
    - No constraints are put on whether the entry point system is initialized more than once - it is just a regular system, which exposes a parameter-less constructor.
- **Static Asserts and Forward Declaration**
  Allowing for both *static asserts* in `PluginSystemRef`and *forward declaration* of plugin systems proves to be a problem, as static assertions require classes to be defined, and not just declared

  - We want to have forward declaration because:

    - Changes to the `.hpp` file will cause recompile of all transient dependencies (e.g. when hot-reloading)
  - **Solution**: because a `PluginSystemRef` does not instantiate the system, and is simple a "holder", we can keep the asserts in other places (e.g. in `PluginManager` when constructing the system). 

    - To accomadate this I moved the *casting* to a utility method in a separate header file, which is likely only ever used in a `.cpp` file (i.e *not* when all you have is a forward declaration)
- **Plugin Systems must be allocated by the Plugin Manager**
  - *Plugin systems cannot be allocated by the plugin to which it belongs:*
  
    - The arguments have to be passed to code defined in the plugin, which I don't think is possible.
  - *Plugin systems cannot be allocated by the plugin where it's needed*:
  
    - If *Plugin A* needs *System 1* from *Plugin B* and *Plugin A* allocated that system, then the memory in which the object is allocated is freed (because it belonged to the plugin) before we reach *System 1* to unload it and serialize it.
    - [?] Why is the memory deallocated together with the library - I thought the memory belonged to the process.
      - E.g. why does it work for plugin_a
      - Good source on some memory management issues with dlls
        https://stackoverflow.com/questions/4031249/dll-memory-management
    - Result: after having a break from it all, there seems to be no problem with the original problem - I must just have missed something somewhere.

- 