# Log

### River Hot-Reloading Prototype



- ... A lot of undocumented stuff

- I don't want to use nested classes, because they cannot be forward declared

- `PluginSystemType` is identified by its plugin name and system name (i.e. the *PluginSystemTypeId*)

  - Pointers to `PluginSystemType` cannot be stored, because the object is constructed at plugin restart, which means it will be re-constructed every time plugin is reloaded
  - In the future, the ID could constructed from a more stable name (i.e. could be retrieved via macro when registering the system)
  - We still have to expose a mapping between the `typeid(S).name()` of the system `S` and the `PluginSystemType`. But this string should *not be stored*, because it might change at every compilation.

- **Serialization**

  - The concrete plugin system has to provide the constructor that deserializes, but it should also be auto-generatable (for the future)

    - You can do this, by having the user add a macro to the system which defines the constructor and then provide implementation of constructor via a separate `.cpp` file (this way you don't touch the user's code)

  - Not using templates to deserialize cause some annoying access patterns:
    ```c++
    : hello_count(((rv::SerializedInt*)serialized_object- >properties.at("hello_count"))->value)
    ```
  
- **Initialization order of systems**
  
  - Order of constructions *could* matter, because one system may depend on some value from another system. **But** deserialization is automated (and code should be autogenerated), and the only thing it does is that it sets the direct values (i.e. no dereferencing of maybe-uninitialized-system).


- **Main Plugin Serialization**
  - *The Problem:*
    The `MainPlugin` needs some kind of serialization, because it creates the first system(s), and these systems are the roots to the dependency tree of systems. This means the plugin must maintain some kind of reference to the system(s), which has to be  maintained on reload.
  - **Solution**
    - We now have an `EntryPointPluginSystem` which is exposed by the `EntryPointPlugin`. This system now contains the update function
    - We are not serializing the plugin, in order to keep it simple (i.e. only systems are serialized).
    - No constraints are put on whether the entry point system is initialized more than once - it is just a regular system, which exposes a parameter-less constructor.

- **Static Asserts and Forward Declaration**
  Allowing for both *static asserts* in `PluginSystemRef`and *forward declaration* of plugin systems proves to be a problem, as static assertions require classes to be defined, and not just declared

  - We want to have forward declaration because:

    - Changes to the `.hpp` file will cause recompile of all transient dependencies (e.g. when hot-reloading)
  - **Solution**: because a `PluginSystemRef` does not instantiate the system, and is simple a "holder", we can keep the asserts in other places (e.g. in `PluginManager` when constructing the system). 

    - To accomadate this I moved the *casting* to a utility method in a separate header file, which is likely only ever used in a `.cpp` file (i.e *not* when all you have is a forward declaration)

- **Plugin Systems must be allocated by the Plugin Manager**
  - *Plugin systems cannot be allocated by the plugin to which it belongs:*

    - The arguments have to be passed to code defined in the plugin, which I don't think is possible.
  - *Plugin systems cannot be allocated by the plugin where it's needed*:

    - If *Plugin A* needs *System 1* from *Plugin B* and *Plugin A* allocated that system, then the memory in which the object is allocated is freed (because it belonged to the plugin) before we reach *System 1* to unload it and serialize it.
    - [?] Why is the memory deallocated together with the library - I thought the memory belonged to the process.
      - E.g. why does it work for plugin_a
      - Good source on some memory management issues with dlls
        https://stackoverflow.com/questions/4031249/dll-memory-management
    - Result: after having a break from it all, there seems to be no problem with the original problem - I must just have missed something somewhere.

- **I removed derived classes of `Plugin` that were local to each plugin project**
  None of the derivations provided any extensions, so there was no need for each plugin project to provide a separate plugin class.
  - *Referencing plugin using type-system:*
    One use-case of the plugin class was to be able to reference the plugin using the *type system*, but I don't see that we'll ever need this, as all code that has to reference a plugin (and not just a system from the plugin) is auto-generated code.

- **Reworked game object system to fit hot-reloading**

  - `ComponentSet` is no longer used explicitly within the derived game object classes, because it meant the components had no names making it difficult to serialize them.
  - Components are constructed via the game object and group together dynamically by specifying *component group index* when constructing it.

- **Setup non-reloadable version of the game object system**


    - All the code is a barebones prototype version.


    - Component set are only implemented in the API, but not internally - components are just heap allocated in isolation.



- **WIP: implement hot reloading in the entity system**

    - I setup construction using lambdas and deferred construction, but with support for only 1 constructor.
    - *A problem:*
        Lambda construction will not work, because what happens if the types that the lambda has captured are also reloaded? Game objects are fine, because we reference them by handle anyway, but what about other structures that may have been exposed by a library?

        - *First idea:* Serialize the lambda (with own lambda type), meaning all passed arguments must also be serializable. Then deserialize it after reload.

            - In case a system wants to handle construction of the object (e.g. because it wants to handle memory management like game objects) the object should have been passed by a handle.
            - Problem: This requires some kind of dynamic dispatching (i.e. calling a function without having the actual type of the function). What do you deserialize the lambda to?
        - *Solution:* Instead of passing all the typed arguments, we serialize the arguments immediately, which we then store, and then we pass those arguments to the constructor proxy, which then deserialize it.
    - Multiple constructors serialization:

        - [!] I postponed working on this until after I got hot reloading with single constructor working.
        - DLL 1 that calls a constructor of game object A has a dependency on A and all of the constructor arguments. The DLL 2 containing A *also* dependencies on all the arguments. This means that 1 and 2 must in sync with regards to the type info of the arguments.

            - I'm not entirely sure about this, and it may need some more experimentation across compilers.

        - Because of the above, it should be possible to find the constructor via reflection by using the `typeid` names of the arguments.
    - Fixing bug:
        Reloading the plugins (if there are changes) crashes, because the game object context is destroyed, but not de-registered properly.
        - The fact that the game object context is destroyed is a problem, because the `PluginManager` reloads the plugin.
        - But the game objects are unloaded by the `PluginManager`, and the "reload" state is stored within the context, so maybe it doesn't make sense that you can create these game object contexts arbitrarily.
        - Options:
            - Serialize the entire game object context. The only additional data is the meta data of the game objects


    - [?] Do components need to be registered as well?

- **Polymorphic dependencies**

    - This can become a bit tricky
    - 3 plugins: A, B, C and D
        - A contains base interface `IBase`
        - B contains implementing class `Impl`
        - C uses base interface `IBase` for something (i.e. it doesn't care about implementation)
        - D constructs `Impl` and passes it to `C`

    - Problem: changes are made to plugin B, meaning all instances of `Impl` must be reloaded, but there is no plugin dependency between B and C (who uses `Impl` without knowing it).
    - Solution: stable handles / identifiers
        - If system C is only referencing the object by handle, then it will not even notice that the object is being reloaded.

- **Handles**

    - Should contain:
        - Some ID (the handle) that you can lookup
        - ...

    - Looking up the value
        - Who owns the mapping?
          - We could have different handle types for different systems, so they can decide themselves how to do the lookup.
        - Is it possible to do a general purpose solution?
          - A system can request some handle storage from a central handle manager, and the system can allocate the handles
          - All handles then refer directly to the handle storage - the handle is typed, so it handles the pointer
          - De-referencing the handle would then be:
            1. Access the handle manager
            2. Find the pool to which the handle belongs
        - [!] Why would we need a general purpose solution?
          - If we simply provide some general templated handle class then it's simply up to the systems to decide how to point the handles to their allocated objects
          - What if you want to allocate an arbitrary object?
          - What if you don't know where the handle might come from (i.e. polymorphism)?




